// Code generated by github.com/yutakahashi114/isutool; DO NOT EDIT.
package isuports

import (
	"encoding/binary"
	"errors"
	"math"
	"time"
)

var (
	_ = math.MaxUint8
)

func (v *Viewer) Encode() ([]byte, error) {
	out := make([]byte, v.MaxSize())

	_n, err := v.EncodeTo(out)
	if err != nil {
		return nil, err
	}

	return out[:_n], nil
}

func (v *Viewer) Decode(in []byte) (*Viewer, error) {
	_, err := DecodeViewer(in, v)
	if err != nil {
		return v, err
	}

	return v, nil
}

func (v *Viewer) MaxSize() int {
	_size := 0

	_size += 1 // is nil
	if v != nil {
		// role
		_size += binary.MaxVarintLen64 + len((*v).role)
		// playerID
		_size += binary.MaxVarintLen64 + len((*v).playerID)
		// tenantName
		_size += binary.MaxVarintLen64 + len((*v).tenantName)
		// tenantID
		_size += binary.MaxVarintLen64
	}
	return _size
}

func (v *Viewer) EncodeTo(out []byte) (int, error) {
	_timeMarshalBinary := func(t time.Time, out []byte) (int, error) {
		var timeZero = time.Time{}.Unix()

		// cf. https://github.com/golang/go/blob/dc00aed6de101700fd02b30f93789b9e9e1fe9a1/src/time/time.go#L1206
		var offsetMin int16 // minutes east of UTC. -1 is UTC.
		var offsetSec int8
		version := 1

		if t.Location() == time.UTC {
			offsetMin = -1
		} else {
			_, offset := t.Zone()
			if offset%60 != 0 {
				version = 2
				offsetSec = int8(offset % 60)
			}

			offset /= 60
			if offset < -32768 || offset == -1 || offset > 32767 {
				return 0, errors.New("TimeMarshalBinary: unexpected zone offset")
			}
			offsetMin = int16(offset)
		}

		unix := t.Unix()
		sec := unix - timeZero
		nsec := t.UnixNano() - unix*1000000000
		out[0] = byte(version)   // byte 0 : version
		out[1] = byte(sec >> 56) // bytes 1-8: seconds
		out[2] = byte(sec >> 48)
		out[3] = byte(sec >> 40)
		out[4] = byte(sec >> 32)
		out[5] = byte(sec >> 24)
		out[6] = byte(sec >> 16)
		out[7] = byte(sec >> 8)
		out[8] = byte(sec)
		out[9] = byte(nsec >> 24) // bytes 9-12: nanoseconds
		out[10] = byte(nsec >> 16)
		out[11] = byte(nsec >> 8)
		out[12] = byte(nsec)
		out[13] = byte(offsetMin >> 8) // bytes 13-14: zone offset in minutes
		out[14] = byte(offsetMin)

		if version == 2 {
			out[15] = byte(offsetSec)
		}

		return 16, nil
	}
	_ = _timeMarshalBinary

	_n := 0

	if v == nil {
		out[_n] = 0
		_n += 1
	} else {
		out[_n] = 1
		_n += 1
		// role
		_n += binary.PutVarint(out[_n:], int64(len((*v).role)))
		_n += copy(out[_n:], (*v).role)
		// playerID
		_n += binary.PutVarint(out[_n:], int64(len((*v).playerID)))
		_n += copy(out[_n:], (*v).playerID)
		// tenantName
		_n += binary.PutVarint(out[_n:], int64(len((*v).tenantName)))
		_n += copy(out[_n:], (*v).tenantName)
		// tenantID
		_n += binary.PutVarint(out[_n:], int64((*v).tenantID))

	}

	return _n, nil
}

func DecodeViewer(in []byte, v *Viewer) (_n int, err error) {
	_n += 1
	if in[0] == 0 {
		return
	}

	// role
	_ƒçvå_roleLen, _ƒçvå_roleLenSize := binary.Varint(in[_n:])
	_n += _ƒçvå_roleLenSize
	(*v).role = string(in[_n : _n+int(_ƒçvå_roleLen)])
	_n += int(_ƒçvå_roleLen)
	// playerID
	_ƒçvå_playerIDLen, _ƒçvå_playerIDLenSize := binary.Varint(in[_n:])
	_n += _ƒçvå_playerIDLenSize
	(*v).playerID = string(in[_n : _n+int(_ƒçvå_playerIDLen)])
	_n += int(_ƒçvå_playerIDLen)
	// tenantName
	_ƒçvå_tenantNameLen, _ƒçvå_tenantNameLenSize := binary.Varint(in[_n:])
	_n += _ƒçvå_tenantNameLenSize
	(*v).tenantName = string(in[_n : _n+int(_ƒçvå_tenantNameLen)])
	_n += int(_ƒçvå_tenantNameLen)
	// tenantID
	_ƒçvå_tenantID, _ƒçvå_tenantIDSize := binary.Varint(in[_n:])
	(*v).tenantID = int64(_ƒçvå_tenantID)
	_n += _ƒçvå_tenantIDSize

	return _n, nil
}
